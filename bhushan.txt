clasified stock 
clasified stock with batch
clasified stock with order














-- performance check

SELECT TOP 20 SUBSTRING(qt.TEXT, (qs.statement_start_offset/2)+1,
((CASE qs.statement_end_offset
WHEN -1 THEN DATALENGTH(qt.TEXT)
ELSE qs.statement_end_offset
END - qs.statement_start_offset)/2)+1),
qs.execution_count,
qs.total_logical_reads, qs.last_logical_reads,
qs.total_logical_writes, qs.last_logical_writes,
qs.total_worker_time,
qs.last_worker_time,
qs.total_elapsed_time/1000000 total_elapsed_time_in_S,
qs.last_elapsed_time/1000000 last_elapsed_time_in_S,
qs.last_execution_time,
qp.query_plan
FROM sys.dm_exec_query_stats qs
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) qt
CROSS APPLY sys.dm_exec_query_plan(qs.plan_handle) qp
ORDER BY qs.total_logical_reads DESC -- logical reads
-- ORDER BY qs.total_logical_writes DESC -- logical writes
-- ORDER BY qs.total_worker_time DESC -- CPU time




-- for optimization if we do LogDatetime indexed  it reduce the time consumption 



-- Use a CTE to simplify and structure the query
WITH OrderItemLogs AS (
    SELECT A.LogDatetime, A.LogAction
    FROM TRN_OrderItemLog A
    INNER JOIN #tblUser U ON A.entryby = U.Client_Id
    LEFT JOIN TRN_Order B ON B.Order_ID = A.Order_ID
        AND B.EntryDate <> A.LogDatetime
    WHERE (@FROMDATE IS NULL OR @TODATE IS NULL OR CONVERT(DATE, B.OrderDate, 103) BETWEEN CONVERT(DATE, @FROMDATE, 103) AND CONVERT(DATE, @TODATE, 103))
)

-- Insert distinct results into temporary table
SELECT DISTINCT CONVERT(VARCHAR(10), LogDatetime, 103) AS LogDate, LogAction
INTO #TBLORDERLOG
FROM OrderItemLogs;




SELECT DISTINCT CONVERT(VARCHAR(10), A.LogDatetime, 103) AS LogDate, A.LogAction
INTO #TBLORDERLOG
FROM TRN_OrderItemLog A
INNER JOIN #tblUser U ON A.entryby = U.Client_Id
LEFT JOIN TRN_Order B WITH (NOLOCK) ON B.Order_ID = A.Order_ID
WHERE (@FROMDATE IS NULL OR @TODATE IS NULL OR CONVERT(DATE, B.OrderDate, 103) BETWEEN CONVERT(DATE, @FROMDATE, 103) AND CONVERT(DATE, @TODATE, 103))
AND B.EntryDate <> A.LogDatetime



indexing on 
TRN_OrderItemLog.entryby, TRN_OrderItemLog.Order_ID, TRN_Order.Order_ID, TRN_Order.OrderDate, and TRN_Order.EntryDate required 

mainly in where condition column   -- partition




[dbo].[Rep_ClasifiedStock]


isnull with 

ex -  Select @IsAgGrid = ISNULL(@IsAgGrid,0)    

 SET @IsAgGrid = NULLIF(@IsAgGrid, '');
 
 
 
 
 







nocount on 

select * from  dbo.table 

if exists(select 1 from table) 

during joins big table at left side and small on right side





1 . 

 SET STATISTICS TIME ON;
	select count(*) from TRN_OrderItemLog
	 SET STATISTICS TIME off;

	  SET STATISTICS TIME ON;
	select count(*) from dbo.TRN_OrderItemLog
	 SET STATISTICS TIME off;


(1 row affected)

 SQL Server Execution Times:
   CPU time = 8986 ms,  elapsed time = 21864 ms.
   
   

(1 row affected)

 SQL Server Execution Times:
   CPU time = 7860 ms,  elapsed time = 19443 ms.

Completion time: 2024-07-16T14:17:53.2163144+05:30





2 . 

SET STATISTICS TIME ON;
 select coalesce(UpdateIP,'') from #test1
SET STATISTICS TIME off;

SET STATISTICS TIME ON;
select ISNULL(UpdateIP,'') from #test2
SET STATISTICS TIME off;


SET STATISTICS TIME ON;
select NULLIF(UpdateIP,'') from #test4
SET STATISTICS TIME off;




(2094 rows affected)

 SQL Server Execution Times:
   CPU time = 0 ms,  elapsed time = 1 ms.

Completion time: 2024-07-16T14:27:56.7928911+05:29


(2094 rows affected)

 SQL Server Execution Times:
   CPU time = 15 ms,  elapsed time = 1 ms.

Completion time: 2024-07-16T14:27:56.7928911+05:30



(2094 rows affected)

 SQL Server Execution Times:
   CPU time = 0 ms,  elapsed time = 1 ms.

Completion time: 2024-07-16T14:27:56.7928911+05:31








3 .

rather than  create temp table , table variable if our (size is small or medium) but we can not use it other codes below like temp 








 declare @test2 table
 (
 id int 
 );
 DECLARE @Counter INT = 1;

-- Loop to insert 1000 rows
SET NOCOUNT ON;
WHILE @Counter <= 40000
BEGIN
    INSERT INTO @test2 
    VALUES 
        (@Counter)
    
    SET @Counter = @Counter + 1;
END;

SET STATISTICS TIME ON;
 select * from @test2
SET STATISTICS TIME off;












 create table #test
 (

 id int 
 )


 drop table #test
 CREATE TABLE #test (
    id INT PRIMARY KEY,
);

-- Declare variables
DECLARE @Counter INT = 1;

-- Loop to insert 1000 rows
SET NOCOUNT ON;
WHILE @Counter <= 40000
BEGIN
    INSERT INTO #test 
    VALUES 
        (@Counter)
    
    SET @Counter = @Counter + 1;
END;

select count(*) from #test




SET STATISTICS TIME ON;
select * from #test
SET STATISTICS TIME off;


temp table takes 16s more for execution and for table variable its o(1) time complexity linear for 40 k row with single column 

































4.
main



[dbo].[Rep_ClasifiedStock] sp 


from @IsAgGrid during create temp table #tblColumns

select more columns and requered less into create temp table query so
rater than fetch unneccesary columns 
so fetching them into cte and use it sub sequently other required places and avoid repetation of query  so it read data from cte (cache memory)

---------
The ColumnMetadata CTE fetches the required columns from sys.columns 
once and uses them in subsequent operations. This improves readability and avoids repetitive querying.
----------------

The INSERT statement explicitly lists columns, ensuring that only necessary columns are inserted. 
This is important for maintaining code correctness and preventing errors.



It ensures that only the necessary columns are populated with data during the insert operation. If the table schema of #tblColumns changes in the future 
(e.g., columns are added or removed), explicitly listing columns prevents unintended errors that could arise from assuming a different column order or missing columns
---------------------------------

Instead of using OBJECT_ID() directly in the WHERE clause, we fetch it once in the CTE (ColumnMetadata). 
This approach can potentially optimize query performance.


---------------







-- Create a temporary table #tblColumns
CREATE TABLE #tblColumns (
    headerName VARCHAR(500),
    children VARCHAR(500),
    field VARCHAR(500),
    headerCheckboxSelection BIT,
    headerCheckboxSelectionFilteredOnly BIT,
    checkboxSelection BIT,
    valueFormatter VARCHAR(500),
    cellRenderer VARCHAR(500),
    rowGroup BIT,
    width VARCHAR(500),
    minWidth VARCHAR(500),
    maxWidth VARCHAR(500),
    hide BIT,
    suppressSizeToFit VARCHAR(500),
    suppressFiltersToolPanel VARCHAR(500),
    suppressColumnsToolPanel VARCHAR(500),
    sortable BIT,
    cellClass VARCHAR(500),
    editable BIT,
    cellEditor VARCHAR(500),
    autoHeight BIT,
    autoWidth BIT DEFAULT 1,
    enableRowGroup BIT
);

-- Fetch column metadata into a CTE
WITH ColumnMetadata AS (
    SELECT
        CASE
            WHEN c.name LIKE '%LOADING%' THEN REPLACE(c.name, 'LOADING', '')
            ELSE REPLACE(c.name, 'Name', '')
        END AS headerName,
        c.name AS children,
        c.name AS field,
        200 AS width,
        CAST(0 AS BIT) AS headerCheckboxSelection,
        CAST(0 AS BIT) AS headerCheckboxSelectionFilteredOnly,
        CAST(0 AS BIT) AS checkboxSelection,
        CASE
            WHEN c.name LIKE '%LoadingQty%' THEN CAST(1 AS BIT)
            ELSE CAST(0 AS BIT)
        END AS hide
    FROM tempdb.sys.columns c
    WHERE c.object_id = OBJECT_ID('tempdb..#tblReport')
)

-- Insert data into #tblColumns from the CTE
INSERT INTO #tblColumns (
    headerName,
    children,
    field,
    width,
    headerCheckboxSelection,
    headerCheckboxSelectionFilteredOnly,
    checkboxSelection,
    hide
)
SELECT
    headerName,
    children,
    field,
    width,
    headerCheckboxSelection,
    headerCheckboxSelectionFilteredOnly,
    checkboxSelection,
    hide
FROM ColumnMetadata;

-- Select data from #tblColumns (for verification or further processing)
SELECT * FROM #tblColumns;

-- Drop the temporary table #tblColumns
DROP TABLE #tblColumns;








-------































SQL Server parse and compile time: 
   CPU time = 0 ms, elapsed time = 0 ms.

 SQL Server Execution Times:
   CPU time = 0 ms,  elapsed time = 0 ms.

 SQL Server Execution Times:
   CPU time = 0 ms,  elapsed time = 0 ms.

 SQL Server Execution Times:
   CPU time = 5707 ms,  elapsed time = 6717 ms.

 SQL Server Execution Times:
   CPU time = 687 ms,  elapsed time = 3751 ms.
Warning: Null value is eliminated by an aggregate or other SET operation.

 SQL Server Execution Times:
   CPU time = 0 ms,  elapsed time = 0 ms.

 SQL Server Execution Times:
   CPU time = 0 ms,  elapsed time = 0 ms.
Warning: Null value is eliminated by an aggregate or other SET operation.

 SQL Server Execution Times:
   CPU time = 78 ms,  elapsed time = 416 ms.

 SQL Server Execution Times:
   CPU time = 16 ms,  elapsed time = 1 ms.

 SQL Server Execution Times:
   CPU time = 6488 ms,  elapsed time = 10903 ms.

Completion time: 2024-07-16T15:59:15.2271327+05:30









work - 

nullif 8s
isnull 9s

















..........................................





SELECT TOP 20 SUBSTRING(qt.TEXT, (qs.statement_start_offset/2)+1,
((CASE qs.statement_end_offset
WHEN -1 THEN DATALENGTH(qt.TEXT)
ELSE qs.statement_end_offset
END - qs.statement_start_offset)/2)+1),
qs.execution_count,
qs.total_logical_reads, qs.last_logical_reads,
qs.total_logical_writes, qs.last_logical_writes,
qs.total_worker_time,
qs.last_worker_time,
qs.total_elapsed_time/1000000 total_elapsed_time_in_S,
qs.last_elapsed_time/1000000 last_elapsed_time_in_S,
qs.last_execution_time,
qp.query_plan
FROM sys.dm_exec_query_stats qs
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) qt
CROSS APPLY sys.dm_exec_query_plan(qs.plan_handle) qp
ORDER BY qs.total_logical_reads DESC -- logical reads
-- ORDER BY qs.total_logical_writes DESC -- logical writes
-- ORDER BY qs.total_worker_time DESC -- CPU time


  
  
  work [Rep_ClasifiedStock_Bk_B_160724] - 6.5 s upto optimized add index to temp table 
  
  [dbo].[Rep_ClasifiedStockAfterOrder_Bk_B_170724]  add index and code change little bit
  
  
  
  
  
  
  
  
set statistics time on;

Select Ord.Order_ID,MAX(Reserve.EntryDate) LastReservation ,min(Reserve.EntryDate) FirstReservation    
Into #ReserveDate  from TRN_Order ORD WITH(NOLOCK)  Left Join TRN_OrderReserve Reserve WITH(NOLOCK) ON  
Reserve.Order_ID = Ord.Order_ID  Group by Ord.Order_ID

set statistics time off

drop table #ReserveDate



set statistics time on;

WITH OrderReservations AS (
    SELECT 
        Order_ID,
        MAX(EntryDate) AS LastReservation,
        MIN(EntryDate) AS FirstReservation
    FROM 
        TRN_OrderReserve WITH(NOLOCK)
    GROUP BY 
        Order_ID
)
SELECT 
    Ord.Order_ID,
    ORes.LastReservation,
    ORes.FirstReservation
INTO #ReserveDate
FROM 
    TRN_Order Ord WITH(NOLOCK)
LEFT JOIN 
    OrderReservations ORes ON ORes.Order_ID = Ord.Order_ID;


set statistics time off;

















-- notes ---------

OPTION (RECOMPILE);

----------------


SET STATISTICS TIME ON;
exec [dbo].[Rep_ItemClasifiedStockWithBatch_BK_B_170724]
SET STATISTICS TIME Off;


 /*
	SQL Server Execution Times:
	CPU time = 19083 ms,  elapsed time = 48388 ms.
   row affected 48225
   execution time 54 S
   */
   
SET STATISTICS time ON;
exec  [dbo].[Rep_ItemClasifiedStockWithBatch_BK_DS_08072024]
SET STATISTICS TIME Off;



  /*
   SQL Server Execution Times:
   CPU time = 38640 ms,  elapsed time = 137613 ms.
   row affected 48225
   execution time 1.51 S 
   */



new sp after the optimization



executation plan for this


table insert #viewstock (29 %)
sorting (7%)
repartition (5%)
joins (3%) each









SET STATISTICS TIME ON;
exec [dbo].[Rep_ItemClasifiedStockWithBatch_BK_B_170724]
SET STATISTICS TIME Off;


 /*
	SQL Server Execution Times:
	CPU time = 19083 ms,  elapsed time = 48388 ms.
   row affected 48225
   execution time 54 S
   */
   
SET STATISTICS time ON;
exec  [dbo].[Rep_ItemClasifiedStockWithBatch_BK_DS_08072024]
SET STATISTICS TIME Off;



  /*
   SQL Server Execution Times:
   CPU time = 38640 ms,  elapsed time = 137613 ms.
   row affected 48225
   execution time 1.51 S 
   */







....................................  18-7-24


Clasifid 
With Bach
AfterOrder
AfterOrderWithbach







set statistics time on

exec [dbo].[Rep_ClasifiedStockAfterOrder_Bk_O_070624]

set statistics time off



/*
 SQL Server Execution Times:
   CPU time = 6406 ms,  elapsed time = 9202 ms.

*/

 set statistics time on

 exec [dbo].[Rep_ClasifiedStockAfterOrder_Bk_B_180724]

 set statistics time off



 /*
  SQL Server Execution Times:
     SQL Server Execution Times:
   CPU time = 5466 ms,  elapsed time = 3785 ms.

	execution time reduce from 9 to 5 s

   */
   
   
   
   
   
   
   task 
   
   ..................
   
   
create proc dynamic_inputs
@display_id int
as
begin

declare @table_name nvarchar(250);
declare @table_column nvarchar(max);
declare @filter_condition nvarchar(max);
declare @Database_name nvarchar(250);
declare @dynamic_sql nvarchar(max);


select  @table_name = Table_Name,@table_column = Select_Cols , @filter_condition = Filter_Cols , @Database_name = DB_names   from test_bhushan.dbo.masters_bhushan where display_id = @display_id


set @dynamic_sql = 'select ' + @table_column + ' from ' + @Database_name + '.dbo.' + @table_name 

if @filter_condition is not null and @filter_condition <> ''
begin

set @dynamic_sql = @dynamic_sql + ' Where ' + @filter_condition

print @dynamic_sql

exec sp_executesql @dynamic_sql

end


end



dynamic_inputs 106




--- 


dynamic sql code for practice



DECLARE @sqlCommand NVARCHAR(MAX);
DECLARE @parameterDefinition NVARCHAR(MAX);
DECLARE @City NVARCHAR(50) = 'New York';
DECLARE @Country NVARCHAR(50) = 'USA';

SET @sqlCommand = 'SELECT * FROM Customers WHERE City = @City AND Country = @Country';
SET @parameterDefinition = '@City NVARCHAR(50), @Country NVARCHAR(50)';

EXEC sp_executesql @sqlCommand, @parameterDefinition, @City, @Country;




---





CREATE OR ALTER PROCEDURE usp_GetEmployeeDetails
    @TableName NVARCHAR(100),
    @ColumnName NVARCHAR(100),
    @SearchKeyword NVARCHAR(100)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @SQL NVARCHAR(MAX);

    -- Build the dynamic SQL statement with a WHERE clause
    SET @SQL = N'SELECT ' + QUOTENAME(@ColumnName) + N' FROM ' + QUOTENAME(@TableName) +
               N' WHERE ' + QUOTENAME(@ColumnName) + N' LIKE @SearchKeyword';

    -- Concatenate the search keyword with wildcards inside the parameter
    SET @SearchKeyword = '%' + @SearchKeyword + '%';

    -- Execute the dynamic SQL statement
    EXEC sp_executesql @SQL, N'@SearchKeyword NVARCHAR(100)', @SearchKeyword = @SearchKeyword;
END;
GO



----------

-- Create a stored procedure for dynamic table creation
CREATE OR ALTER PROCEDURE usp_CreateDynamicTable
    @TableName NVARCHAR(100),
    @ColumnsDefinition NVARCHAR(MAX)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @SQL NVARCHAR(MAX);

    -- Build the dynamic SQL statement to create table
    SET @SQL = N'CREATE TABLE ' + QUOTENAME(@TableName) + N' (' + @ColumnsDefinition + N')';

    -- Execute the dynamic SQL statement
    EXEC sp_executesql @SQL;
END;
GO


-----------------

-- Create a stored procedure for dynamic insert
CREATE OR ALTER PROCEDURE usp_DynamicInsert
    @TableName NVARCHAR(100),
    @Columns NVARCHAR(MAX),
    @Values NVARCHAR(MAX)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @SQL NVARCHAR(MAX);

    -- Build the dynamic SQL statement for insert
    SET @SQL = N'INSERT INTO ' + QUOTENAME(@TableName) + N' (' + @Columns + N') ' +
               N'VALUES (' + @Values + N')';

    -- Execute the dynamic SQL statement
    EXEC sp_executesql @SQL;
END;
GO



EXEC usp_DynamicInsert 'Employees', '[EmployeeID], [FirstName], [LastName]', '101, ''John'', ''Doe''';



-----------------




-- Create a stored procedure for dynamic column selection
CREATE OR ALTER PROCEDURE usp_DynamicColumnSelect
    @TableName NVARCHAR(100),
    @Columns NVARCHAR(MAX)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @SQL NVARCHAR(MAX);

    -- Build the dynamic SQL statement for select
    SET @SQL = N'SELECT ' + @Columns + N' FROM ' + QUOTENAME(@TableName);

    -- Execute the dynamic SQL statement
    EXEC sp_executesql @SQL;
END;
GO





EXEC usp_DynamicColumnSelect 'Employees', '[EmployeeID], [FirstName], [LastName]';





--------- 


-- Create a stored procedure for dynamic update
CREATE OR ALTER PROCEDURE usp_DynamicUpdate
    @TableName NVARCHAR(100),
    @SetClause NVARCHAR(MAX),
    @Condition NVARCHAR(MAX)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @SQL NVARCHAR(MAX);

    -- Build the dynamic SQL statement for update
    SET @SQL = N'UPDATE ' + QUOTENAME(@TableName) +
               N' SET ' + @SetClause +
               N' WHERE ' + @Condition;

    -- Execute the dynamic SQL statement
    EXEC sp_executesql @SQL;
END;
GO




EXEC usp_DynamicUpdate 'Employees', 'Salary = 50000, Department = ''IT''', 'EmployeeID = 101';


---------

-- Create a stored procedure for dynamic delete with join
CREATE OR ALTER PROCEDURE usp_DynamicDeleteWithJoin
    @PrimaryTableName NVARCHAR(100),
    @JoinTableName NVARCHAR(100),
    @Condition NVARCHAR(MAX)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @SQL NVARCHAR(MAX);

    -- Build the dynamic SQL statement for delete with join
    SET @SQL = N'DELETE ' + QUOTENAME(@PrimaryTableName) +
               N' FROM ' + QUOTENAME(@PrimaryTableName) + N' AS PT ' +
               N' INNER JOIN ' + QUOTENAME(@JoinTableName) + N' AS JT ON ' + @Condition;

    -- Execute the dynamic SQL statement
    EXEC sp_executesql @SQL;
END;
GO





EXEC usp_DynamicDeleteWithJoin 'Employees', 'Departments', 'PT.DepartmentID = JT.DepartmentID AND JT.DepartmentName = ''HR''';





-------


-- Create a stored procedure for dynamic backup and restore
CREATE OR ALTER PROCEDURE usp_DynamicBackupRestore
    @Operation NVARCHAR(50),
    @TableName NVARCHAR(100),
    @BackupFilePath NVARCHAR(200)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @SQL NVARCHAR(MAX);

    -- Build the dynamic SQL statement based on operation
    IF @Operation = 'BACKUP'
    BEGIN
        SET @SQL = N'BACKUP DATABASE ' + QUOTENAME(DB_NAME()) +
                   N' TO DISK = ' + QUOTENAME(@BackupFilePath);
    END
    ELSE IF @Operation = 'RESTORE'
    BEGIN
        SET @SQL = N'RESTORE DATABASE ' + QUOTENAME(DB_NAME()) +
                   N' FROM DISK = ' + QUOTENAME(@BackupFilePath) +
                   N' WITH REPLACE';
    END
    ELSE
    BEGIN
        RAISEERROR('Invalid operation specified.', 16, 1);
        RETURN;
    END

    -- Execute the dynamic SQL statement
    EXEC sp_executesql @SQL;
END;
GO



EXEC usp_DynamicBackupRestore 'BACKUP', 'YourDatabaseName', 'C:\Backup\YourDatabase.bak';
EXEC usp_DynamicBackupRestore 'RESTORE', 'YourDatabaseName', 'C:\Backup\YourDatabase.bak';



-----------




-- Create a stored procedure for dynamic schema manipulation
CREATE OR ALTER PROCEDURE usp_DynamicSchemaManipulation
    @TableName NVARCHAR(100),
    @ColumnName NVARCHAR(100),
    @DataType NVARCHAR(50)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @SQL NVARCHAR(MAX);

    -- Build the dynamic SQL statement to add a column
    SET @SQL = N'ALTER TABLE ' + QUOTENAME(@TableName) +
               N' ADD ' + QUOTENAME(@ColumnName) + N' ' + @DataType;

    -- Execute the dynamic SQL statement
    EXEC sp_executesql @SQL;
END;
GO



EXEC usp_DynamicSchemaManipulation 'Employees', 'DateOfBirth', 'DATE';



-----------




-- Create a stored procedure for dynamic transaction handling
CREATE OR ALTER PROCEDURE usp_DynamicTransactionHandling
    @OperationType NVARCHAR(50),
    @TableName NVARCHAR(100),
    @Values NVARCHAR(MAX)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @SQL NVARCHAR(MAX);

    BEGIN TRY
        -- Start the transaction
        BEGIN TRANSACTION;

        -- Build the dynamic SQL statement based on operation type
        IF @OperationType = 'INSERT'
        BEGIN
            SET @SQL = N'INSERT INTO ' + QUOTENAME(@TableName) + N' VALUES (' + @Values + N')';
        END
        ELSE IF @OperationType = 'DELETE'
        BEGIN
            SET @SQL = N'DELETE FROM ' + QUOTENAME(@TableName) + N' WHERE ' + @Values;
        END
        ELSE
        BEGIN
            RAISEERROR('Invalid operation type specified.', 16, 1);
            RETURN;
        END

        -- Execute the dynamic SQL statement
        EXEC sp_executesql @SQL;

        -- Commit the transaction
        COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        -- Rollback the transaction on error
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;

        -- Throw or handle the error as needed
        THROW;
    END CATCH
END;
GO






EXEC usp_DynamicTransactionHandling 'INSERT', 'Employees', '101, ''John'', ''Doe''';
EXEC usp_DynamicTransactionHandling 'DELETE', 'Employees', 'EmployeeID = 101';



-------






-- Create a stored procedure for dynamic index creation and maintenance
CREATE OR ALTER PROCEDURE usp_DynamicIndexCreation
    @TableName NVARCHAR(100),
    @IndexName NVARCHAR(100),
    @Columns NVARCHAR(MAX),
    @IncludeColumns NVARCHAR(MAX) = NULL,
    @WhereClause NVARCHAR(MAX) = NULL
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @SQL NVARCHAR(MAX);

    -- Build the dynamic SQL statement for index creation
    SET @SQL = N'CREATE INDEX ' + QUOTENAME(@IndexName) +
               N' ON ' + QUOTENAME(@TableName) + N' (' + @Columns + N')';

    -- Optionally include included columns
    IF @IncludeColumns IS NOT NULL
    BEGIN
        SET @SQL = @SQL + N' INCLUDE (' + @IncludeColumns + N')'


    -- Optionally include WHERE clause for filtered index
    IF @WhereClause IS NOT NULL
    BEGIN
        SET @SQL = @SQL + N' WHERE ' + @WhereClause;
    END

    -- Execute the dynamic SQL statement
    EXEC sp_executesql @SQL;
END;
GO




EXEC usp_DynamicIndexCreation 'Employees', 'IX_Employees_DepartmentID', 'DepartmentID';
EXEC usp_DynamicIndexCreation 'SalesData', 'IX_SalesData_ProductID', 'ProductID', 'OrderDate > ''2023-01-01''';




--------------



-- Create a stored procedure for dynamic XML generation from table data
CREATE OR ALTER PROCEDURE usp_DynamicXmlGeneration
    @TableName NVARCHAR(100),
    @ColumnName NVARCHAR(100),
    @Condition NVARCHAR(MAX)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @SQL NVARCHAR(MAX);

    -- Build the dynamic SQL statement for XML generation
    SET @SQL = N'SELECT ' +
               N' (SELECT ' + @ColumnName + N' AS Name, ' +
               N'        (SELECT * FROM ' + @TableName + N' WHERE ' + @Condition + N' FOR XML PATH(''Row''), TYPE) AS Data ' +
               N' FOR XML PATH(''Table'')';

    -- Execute the dynamic SQL statement
    EXEC sp_executesql @SQL;
END;
GO




EXEC usp_DynamicXmlGeneration 'Employees', 'EmployeeID, FirstName, LastName', 'Salary > 50000';



--------------


-- Create a stored procedure for dynamic bulk insert from CSV file
CREATE OR ALTER PROCEDURE usp_DynamicBulkInsertFromCSV
    @TableName NVARCHAR(100),
    @CSVFilePath NVARCHAR(200)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @SQL NVARCHAR(MAX);

    -- Build the dynamic SQL statement for bulk insert
    SET @SQL = N'BULK INSERT ' + QUOTENAME(@TableName) +
               N' FROM ' + QUOTENAME(@CSVFilePath) +
               N' WITH (FIELDTERMINATOR = '','', ROWTERMINATOR = ''\n'', FIRSTROW = 2)'; -- Assuming first row is header

    -- Execute the dynamic SQL statement
    EXEC sp_executesql @SQL;
END;
GO



EXEC usp_DynamicBulkInsertFromCSV 'Employees', 'C:\Data\employees.csv';






-----------------




-- Create a stored procedure for dynamic cross-database queries
CREATE OR ALTER PROCEDURE usp_DynamicCrossDatabaseQuery
    @DatabaseName NVARCHAR(100),
    @SchemaName NVARCHAR(100),
    @TableName NVARCHAR(100)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @SQL NVARCHAR(MAX);

    -- Build the dynamic SQL statement for cross-database query
    SET @SQL = N'SELECT * FROM ' + QUOTENAME(@DatabaseName) + N'.' + QUOTENAME(@SchemaName) + N'.' + QUOTENAME(@TableName);

    -- Execute the dynamic SQL statement
    EXEC sp_executesql @SQL;
END;
GO



EXEC usp_DynamicCrossDatabaseQuery 'OtherDatabase', 'dbo', 'OtherTable';





---------------------







